View(sel)
View(sel)
f1Resample = jitter(sel$x1)
f1Resample = jitter(sel$x4)
View(sel)
sel$x4 = jitter(sel$x3)
View(sel)
sel2 = sapply(X = sel[, 1:3], FUN = jitter)
View(sel2)
input = generateInput(batchSize, seed = sample(1:10000, size = 1), dimensions = dimensions)
#pose first request for first sample
output = cbind(input,
func1 = apirequest(input = input[,1:3], func = 1, endpoint = endpoint, base = base, token = token),
func2 = apirequest(input = input[,1:3], func = 2, endpoint = endpoint, base = base, token = token))
#fit function to dataframe
f1 = lm(func1 ~ x1 + x2 + x3, data = output)
#calculate confidence intervals
conf = as.data.frame(predict(f1, newdata = output[,1:3], interval = "confidence"))
#select highest intervals, select input points, jitter them to create variability, request
output$high = abs(conf$lwr - conf$upr)
sel = dplyr::arrange(output, desc(high))[1:10,]
input = sapply(sel[,1:3], jitter)
iteration = cbind(input,
func1 = apirequest(input = input[,1:3], func = 1, endpoint = endpoint, base = base, token = token),
func2 = apirequest(input = input[,1:3], func = 2, endpoint = endpoint, base = base, token = token))
output = rbind(output, iteration)
outDf = data.frame()
input = generateInput(batchSize, seed = sample(1:10000, size = 1), dimensions = dimensions)
#pose first request for first sample
output = cbind(input,
func1 = apirequest(input = input[,1:3], func = 1, endpoint = endpoint, base = base, token = token),
func2 = apirequest(input = input[,1:3], func = 2, endpoint = endpoint, base = base, token = token))
outDf = data.frame()
input = generateInput(batchSize, seed = sample(1:10000, size = 1), dimensions = dimensions)
#pose first request for first sample
output = cbind(input,
func1 = apirequest(input = input[,1:3], func = 1, endpoint = endpoint, base = base, token = token),
func2 = apirequest(input = input[,1:3], func = 2, endpoint = endpoint, base = base, token = token))
#fit function to dataframe for function1
f1 = lm(func1 ~ x1 + x2 + x3, data = output)
#calculate confidence intervals
conf = as.data.frame(predict(f1, newdata = output[,1:3], interval = "confidence"))
#select highest intervals, select input points
output$high = abs(conf$lwr - conf$upr)
sel1 = dplyr::arrange(output, desc(high))[1:10,]
#fit function to dataframe for function 2
f2 = lm(func2 ~ x1 + x2 + x3, data = output)
#calculate confidence intervals
conf = as.data.frame(predict(f2, newdata = output[,1:3], interval = "confidence"))
#select highest intervals, select input points
output$high = abs(conf$lwr - conf$upr)
sel2 = dplyr::arrange(output, desc(high))[1:10,]
input = sapply(rbind(sel1[,1:3],sel2[,1:3]), jitter)
input = as.data.frame(sapply(rbind(sel1[,1:3],sel2[,1:3]), jitter))
View(input)
#check for values out of bounds
#request top 20 most unsecure predictions of both functions
iteration = cbind(input,
func1 = apirequest(input = input[,1:3], func = 1, endpoint = endpoint, base = base, token = token),
func2 = apirequest(input = input[,1:3], func = 2, endpoint = endpoint, base = base, token = token))
View(iteration)
#check for values out of bounds
#request top 20 most unsecure predictions of both functions
iteration = cbind(input,
func1 = apirequest(input = input[,1:3], func = 1, endpoint = endpoint, base = base, token = token),
func2 = apirequest(input = input[,1:3], func = 2, endpoint = endpoint, base = base, token = token))
View(input)
source("sourcer.R")
#check for values out of bounds
#request top 20 most unsecure predictions of both functions
iteration = cbind(input,
func1 = apirequest(input = input[,1:3], func = 1, endpoint = endpoint, base = base, token = token),
func2 = apirequest(input = input[,1:3], func = 2, endpoint = endpoint, base = base, token = token))
View(iteration)
View(input)
#check for values out of bounds (-5,5) - even though Api allows for requests out of bounds?
input = input[x1 <= 5 & x1 >= -5 & x2 <= 5 & x2 >= -5 & x3 <= 5 & x3 >= -5, ]
#check for values out of bounds (-5,5) - even though Api allows for requests out of bounds?
input = input[input$x1 <= 5 & input$x1 >= -5 & input$x2 <= 5 & input$x2 >= -5 & input$x3 <= 5 & input$x3 >= -5, ]
View(input)
input_intermediate = 1:nrow(input)
for(i in 1:nrow(input)){
input_intermediate[i]=paste0(input[i,],collapse = ",")
}
data=paste0(input_intermediate, collapse =";")
print(paste0("requesting ", nrow(input), " observations..."))
call= paste(base,"/",endpoint,"/",func,"/",token,"/",data,sep="")
func = 1
call= paste(base,"/",endpoint,"/",func,"/",token,"/",data,sep="")
#API-Request
data_raw=GET(call)
#extracting content from API response, convert to JSON
data_json=content(data_raw,"text")
View(data_raw)
#parsing the JSON format
data_json_parsed = fromJSON(data_json, flatten = TRUE)
View(data_json_parsed)
data_json_parsed[2
data_json_parsed[2]
data_json_parsed[2]
data_json_parsed[["remaining"]]
x1 = sample(seq(-5, 5, by = 0.2))
x2 = sample(seq(-5, 5, by = 0.2))
x3 = sample(seq(-5, 5, by = 0.2))
input = data.frame(x1 = x1[1:50], x2 = x2[1:50], x3 = x3[1:50], seed = seed)
View(input)
seed = 1
print(paste("generating random sample with seed" , seed))
seed = seed
set.seed(seed)
if(dimensions == 3){
x1 = sample(seq(-5, 5, by = 0.2))
x2 = sample(seq(-5, 5, by = 0.2))
x3 = sample(seq(-5, 5, by = 0.2))
input = data.frame(x1 = x1[1:50], x2 = x2[1:50], x3 = x3[1:50], seed = seed)
}
else{
x1 = sample(seq(-5, 5, by = 0.2))
x2 = sample(seq(-5, 5, by = 0.2))
input = data.frame(x1 = x1[1:50], x2 = x2[1:50], seed = seed)
}
return(input)
input = data.frame(x1 = x1[1:50], x2 = x2[1:50], x3 = x3[1:50], seed = seed)
View(input)
source("sourcer.R")
source("sourcer.R")
###Master###
setwd("C:/Users/felix/Google Drive/Master/WWU/Data Analytics 2/MultObjOptimisation")
View(visualiseDatapoints)
base="optim.uni-muenster.de:5000/"
token="866de98d0d47426e92cc0e3394df5f07"
endpoint = "api-test3D"
if(endpoint == "api-test3D"){
dimensions = 3
}
if(endpoint == "api-test2D") {
dimensions = 2
}
batchSize = 50
#import data and build dataframe for observations and the two target variables.
dataframe = generateDataFrames(endpoint = endpoint, batchSize = batchSize, loops = 20, base = base,
token = token, dimensions = dimensions, sample = "intelligent")
#'@description generate data and request responses from api to build dataframes
#'@author: Felix
#'@param fun: function that needs to be approximated
#'@param endpoint: endpoint that will be used
#'@param batchSize: batchSize of observations to be requested from the API; default = 50
generateDataFrames = function(endpoint = "api-test2D", batchSize = 50, loops = 1, base, token, dimensions = 2, sample = "intelligent"){
outDf = data.frame()
if(sample == "random") {
for(loop in 1:loops){
input = generateInput(batchSize, seed = sample(1:10000, size = 1), dimensions = dimensions)
print(input)
if(dimensions == 3){
output = cbind(input,
func1 = apirequest(input = input[,1:3], func = 1, endpoint = endpoint, base = base, token = token),
func2 = apirequest(input = input[,1:3], func = 2, endpoint = endpoint, base = base, token = token))
}
else{
output = cbind(input,
func1 = apirequest(input = input[,1:2], func = 1, endpoint = endpoint, base = base, token = token),
func2 = apirequest(input = input[,1:2], func = 2, endpoint = endpoint, base = base, token = token))
}
outDf = rbind(outDf, output)
}
return(outDf)
}
if(sample == "intelligent") {
#generate initial sample. Uniform from space with random arrangement
input = generateInput(batchSize, seed = sample(1:10000, size = 1), dimensions = dimensions)
input$seed = NULL
if(dimensions == 3){
#request initial sample
output = cbind(input,
func1 = apirequest(input = input[,1:3], func = 1, endpoint = endpoint, base = base, token = token),
func2 = apirequest(input = input[,1:3], func = 2, endpoint = endpoint, base = base, token = token))
for(i in loops){
iteration = intelligentSample(output = output, endpoint = endpoint, token = token, base = base, dimensions = dimensions)
output = rbind(output, iteration)
}
}
else{
#request initial sample
output = cbind(input,
func1 = apirequest(input = input[,1:2], func = 1, endpoint = endpoint, base = base, token = token),
func2 = apirequest(input = input[,1:2], func = 2, endpoint = endpoint, base = base, token = token))
for(i in loops){
iteration = intelligentSample(output = output, endpoint = endpoint, token = token, base = base, dimensions = dimensions)
output = rbind(output, iteration)
}
}
return(output)
}
}
####only for use if adaptive sampling does not work####
#' @description generate hypercube input variables for api requests [-5:5]
#' @author: Felix
#' @param batchSize: Size of df to be generated
#' @param mode: how do are these samples generated
generateInput = function(batchSize = 50, seed, dimensions) {
print(paste("generating random sample with seed" , seed))
seed = seed
set.seed(seed)
if(dimensions == 3){
x1 = sample(seq(-5, 5, by = 0.2))
x2 = sample(seq(-5, 5, by = 0.2))
x3 = sample(seq(-5, 5, by = 0.2))
input = data.frame(x1 = x1[1:50], x2 = x2[1:50], x3 = x3[1:50], seed = seed)
}
else{
x1 = sample(seq(-5, 5, by = 0.2))
x2 = sample(seq(-5, 5, by = 0.2))
input = data.frame(x1 = x1[1:50], x2 = x2[1:50], seed = seed)
}
return(input)
}
intelligentSample = function(output, endpoint, base, token, dimensions){
if(dimensions == 3) {
#fit function to dataframe for function1
f1 = lm(func1 ~ x1 + x2 + x3, data = output)
#calculate confidence intervals
conf = as.data.frame(predict(f1, newdata = output[,1:3], interval = "confidence"))
#select highest intervals, select input points
output$high = abs(conf$lwr - conf$upr)
sel1 = dplyr::arrange(output, desc(high))[1:10,]
#fit function to dataframe for function 2
f2 = lm(func2 ~ x1 + x2 + x3, data = output)
#calculate confidence intervals
conf = as.data.frame(predict(f2, newdata = output[,1:3], interval = "confidence"))
#select highest intervals, select input points
output$high = abs(conf$lwr - conf$upr)
sel2 = dplyr::arrange(output, desc(high))[1:10,]
input = as.data.frame(sapply(rbind(sel1[,1:3],sel2[,1:3]), jitter))
#check for values out of bounds (-5,5) - even though Api allows for requests out of bounds?
input = input[input$x1 <= 5 & input$x1 >= -5 & input$x2 <= 5 & input$x2 >= -5 & input$x3 <= 5 & input$x3 >= -5, ]
#request top 20 most varied predictions of both functions
iteration = cbind(input,
func1 = apirequest(input = input[,1:3], func = 1, endpoint = endpoint, base = base, token = token),
func2 = apirequest(input = input[,1:3], func = 2, endpoint = endpoint, base = base, token = token))
}
else{
#fit function to dataframe for function1
f1 = lm(func1 ~ x1 + x2, data = output)
#calculate confidence intervals
conf = as.data.frame(predict(f1, newdata = output[,1:2], interval = "confidence"))
#select highest intervals, select input points
output$high = abs(conf$lwr - conf$upr)
sel1 = dplyr::arrange(output, desc(high))[1:10,]
#fit function to dataframe for function 2
f2 = lm(func2 ~ x1 + x2, data = output)
#calculate confidence intervals
conf = as.data.frame(predict(f2, newdata = output[,1:2], interval = "confidence"))
#select highest intervals, select input points
output$high = abs(conf$lwr - conf$upr)
sel2 = dplyr::arrange(output, desc(high))[1:10,]
input = as.data.frame(sapply(rbind(sel1[,1:2],sel2[,1:2]), jitter))
#check for values out of bounds (-5,5) - even though Api allows for requests out of bounds?
input = input[input$x1 <= 5 & input$x1 >= -5 & input$x2 <= 5 & input$x2 >= -5, ]
#request top 20 most varied predictions of both functions
iteration = cbind(input,
func1 = apirequest(input = input[,1:2], func = 1, endpoint = endpoint, base = base, token = token),
func2 = apirequest(input = input[,1:2], func = 2, endpoint = endpoint, base = base, token = token))
}
return(iteration)
}
#import data and build dataframe for observations and the two target variables.
dataframe = generateDataFrames(endpoint = endpoint, batchSize = batchSize, loops = 20, base = base,
token = token, dimensions = dimensions, sample = "intelligent")
View(dataframe)
#visualise these datapoints in a 3D explorable space.
visualiseDatapoints(dataframe = dataframe, dimensions = dimensions, mode = "all")
View(visualiseDatapoints)
compDataframe1 = dataframe[, -5]
View(compDataframe1)
colnames(compDataframe1)[4] = "target"
compDataframe1$group = 1
compDataframe2 = dataframe[, -4]
colnames(compDataframe2)[4] = "target"
compDataframe2$group = 2
compDataframe = rbind(compDataframe1, compDataframe2)
View(compDataframe)
scatter3D(x = compDataframe$x1, y = compDataframe$target, z= compDataframe$x2, phi = 0, theta = 100,
colvar = compDataframe$group,
col = c("#7570B3", "#D95F02"), main = "Datapoints",
ylab = "Target", xlab = "X1", zlab = "X2")
plotrgl()
compDataframe1 = dataframe[, -6]
colnames(compDataframe1)[5] = "target"
compDataframe1$group = 1
compDataframe2 = dataframe[, -5]
colnames(compDataframe2)[5] = "target"
compDataframe2$group = 2
compDataframe1 = dataframe[, -6]
colnames(compDataframe1)[5] = "target"
compDataframe1$group = 1
View(dataframe)
compDataframe1 = dataframe[, -6]
View(dataframe)
compDataframe1 = dataframe[, -5]
colnames(compDataframe1)[5] = "target"
compDataframe1$group = 1
compDataframe1 = dataframe[, -5]
colnames(compDataframe1)[5] = "target"
compDataframe1$group = 1
compDataframe1 = dataframe[, -5]
colnames(compDataframe1)[5] = "target"
compDataframe1$group = 1
View(compDataframe1)
colnames(compDataframe1)[4] = "target"
compDataframe1$group = 1
compDataframe2 = dataframe[, -4]
compDataframe2$group = 2
colnames(compDataframe2)[4] = "target"
compDataframe = rbind(compDataframe1, compDataframe2)
View(compDataframe)
###Master###
setwd("C:/Users/felix/Google Drive/Master/WWU/Data Analytics 2/MultObjOptimisation")
source("sourcer.R")
base="optim.uni-muenster.de:5000/"
token="866de98d0d47426e92cc0e3394df5f07"
endpoint = "api-test3D"
if(endpoint == "api-test3D"){
dimensions = 3
}
if(endpoint == "api-test2D") {
dimensions = 2
}
batchSize = 50
#import data and build dataframe for observations and the two target variables.
dataframe = generateDataFrames(endpoint = endpoint, batchSize = batchSize, loops = 20, base = base,
token = token, dimensions = dimensions, sample = "intelligent")
#visualise these datapoints in a 3D explorable space.
visualiseDatapoints(dataframe = dataframe, dimensions = dimensions, mode = "all")
endpoint = "api-test2D"
if(endpoint == "api-test3D"){
dimensions = 3
}
if(endpoint == "api-test2D") {
dimensions = 2
}
#import data and build dataframe for observations and the two target variables.
dataframe = generateDataFrames(endpoint = endpoint, batchSize = batchSize, loops = 20, base = base,
token = token, dimensions = dimensions, sample = "intelligent")
#visualise these datapoints in a 3D explorable space.
visualiseDatapoints(dataframe = dataframe, dimensions = dimensions, mode = "all")
#'@description generate data and request responses from api to build dataframes
#'@author: Felix
#'@param fun: function that needs to be approximated
#'@param endpoint: endpoint that will be used
#'@param batchSize: batchSize of observations to be requested from the API; default = 50
generateDataFrames = function(endpoint = "api-test2D", batchSize = 50, loops = 1, base, token, dimensions = 2, sample = "intelligent"){
outDf = data.frame()
if(sample == "random") {
for(loop in 1:loops){
input = generateInput(batchSize, seed = sample(1:10000, size = 1), dimensions = dimensions)
print(input)
if(dimensions == 3){
output = cbind(input,
func1 = apirequest(input = input[,1:3], func = 1, endpoint = endpoint, base = base, token = token),
func2 = apirequest(input = input[,1:3], func = 2, endpoint = endpoint, base = base, token = token))
}
else{
output = cbind(input,
func1 = apirequest(input = input[,1:2], func = 1, endpoint = endpoint, base = base, token = token),
func2 = apirequest(input = input[,1:2], func = 2, endpoint = endpoint, base = base, token = token))
}
outDf = rbind(outDf, output)
}
return(outDf)
}
if(sample == "intelligent") {
#generate initial sample. Uniform from space with random arrangement
input = generateInput(batchSize, seed = sample(1:10000, size = 1), dimensions = dimensions)
input$seed = NULL
if(dimensions == 3){
#request initial sample
output = cbind(input,
func1 = apirequest(input = input[,1:3], func = 1, endpoint = endpoint, base = base, token = token),
func2 = apirequest(input = input[,1:3], func = 2, endpoint = endpoint, base = base, token = token))
for(i in 1:loops){
iteration = intelligentSample(output = output, endpoint = endpoint, token = token, base = base, dimensions = dimensions)
output = rbind(output, iteration)
}
}
else{
#request initial sample
output = cbind(input,
func1 = apirequest(input = input[,1:2], func = 1, endpoint = endpoint, base = base, token = token),
func2 = apirequest(input = input[,1:2], func = 2, endpoint = endpoint, base = base, token = token))
for(i in 1:loops){
iteration = intelligentSample(output = output, endpoint = endpoint, token = token, base = base, dimensions = dimensions)
output = rbind(output, iteration)
}
}
return(output)
}
}
####only for use if adaptive sampling does not work####
#' @description generate hypercube input variables for api requests [-5:5]
#' @author: Felix
#' @param batchSize: Size of df to be generated
#' @param mode: how do are these samples generated
generateInput = function(batchSize = 50, seed, dimensions) {
print(paste("generating random sample with seed" , seed))
seed = seed
set.seed(seed)
if(dimensions == 3){
x1 = sample(seq(-5, 5, by = 0.2))
x2 = sample(seq(-5, 5, by = 0.2))
x3 = sample(seq(-5, 5, by = 0.2))
input = data.frame(x1 = x1[1:50], x2 = x2[1:50], x3 = x3[1:50], seed = seed)
}
else{
x1 = sample(seq(-5, 5, by = 0.2))
x2 = sample(seq(-5, 5, by = 0.2))
input = data.frame(x1 = x1[1:50], x2 = x2[1:50], seed = seed)
}
return(input)
}
intelligentSample = function(output, endpoint, base, token, dimensions){
if(dimensions == 3) {
#fit function to dataframe for function1
f1 = lm(func1 ~ x1 + x2 + x3, data = output)
#calculate confidence intervals
conf = as.data.frame(predict(f1, newdata = output[,1:3], interval = "confidence"))
#select highest intervals, select input points
output$high = abs(conf$lwr - conf$upr)
sel1 = dplyr::arrange(output, desc(high))[1:10,]
#fit function to dataframe for function 2
f2 = lm(func2 ~ x1 + x2 + x3, data = output)
#calculate confidence intervals
conf = as.data.frame(predict(f2, newdata = output[,1:3], interval = "confidence"))
#select highest intervals, select input points
output$high = abs(conf$lwr - conf$upr)
sel2 = dplyr::arrange(output, desc(high))[1:10,]
input = as.data.frame(sapply(rbind(sel1[,1:3],sel2[,1:3]), jitter))
#check for values out of bounds (-5,5) - even though Api allows for requests out of bounds?
input = input[input$x1 <= 5 & input$x1 >= -5 & input$x2 <= 5 & input$x2 >= -5 & input$x3 <= 5 & input$x3 >= -5, ]
#request top 20 most varied predictions of both functions
iteration = cbind(input,
func1 = apirequest(input = input[,1:3], func = 1, endpoint = endpoint, base = base, token = token),
func2 = apirequest(input = input[,1:3], func = 2, endpoint = endpoint, base = base, token = token))
}
else{
#fit function to dataframe for function1
f1 = lm(func1 ~ x1 + x2, data = output)
#calculate confidence intervals
conf = as.data.frame(predict(f1, newdata = output[,1:2], interval = "confidence"))
#select highest intervals, select input points
output$high = abs(conf$lwr - conf$upr)
sel1 = dplyr::arrange(output, desc(high))[1:10,]
#fit function to dataframe for function 2
f2 = lm(func2 ~ x1 + x2, data = output)
#calculate confidence intervals
conf = as.data.frame(predict(f2, newdata = output[,1:2], interval = "confidence"))
#select highest intervals, select input points
output$high = abs(conf$lwr - conf$upr)
sel2 = dplyr::arrange(output, desc(high))[1:10,]
input = as.data.frame(sapply(rbind(sel1[,1:2],sel2[,1:2]), jitter))
#check for values out of bounds (-5,5) - even though Api allows for requests out of bounds?
input = input[input$x1 <= 5 & input$x1 >= -5 & input$x2 <= 5 & input$x2 >= -5, ]
#request top 20 most varied predictions of both functions
iteration = cbind(input,
func1 = apirequest(input = input[,1:2], func = 1, endpoint = endpoint, base = base, token = token),
func2 = apirequest(input = input[,1:2], func = 2, endpoint = endpoint, base = base, token = token))
}
return(iteration)
}
Sys.sleep(10)
source("sourcer.R")
endpoint = "api-test2D"
if(endpoint == "api-test3D"){
dimensions = 3
}
if(endpoint == "api-test2D") {
dimensions = 2
}
batchSize = 50
#import data and build dataframe for observations and the two target variables.
dataframe = generateDataFrames(endpoint = endpoint, batchSize = batchSize, loops = 20, base = base,
token = token, dimensions = dimensions, sample = "intelligent")
source("sourcer.R")
#import data and build dataframe for observations and the two target variables.
dataframe = generateDataFrames(endpoint = endpoint, batchSize = batchSize, loops = 20, base = base,
token = token, dimensions = dimensions, sample = "intelligent")
source("sourcer.R")
#import data and build dataframe for observations and the two target variables.
dataframe = generateDataFrames(endpoint = endpoint, batchSize = batchSize, loops = 20, base = base,
token = token, dimensions = dimensions, sample = "intelligent")
View(dataframe)
#visualise these datapoints in a 3D explorable space.
visualiseDatapoints(dataframe = dataframe, dimensions = dimensions, mode = "all")
#visualise these datapoints in a 3D explorable space.
visualiseDatapoints(dataframe = dataframe, dimensions = dimensions, mode = "all")
seq(1:100, by = 10)
seq(1, 100, by = 5)
source("sourcer.R")
source("sourcer.R")
#import data and build dataframe for observations and the two target variables.
dataframe = generateDataFrames(endpoint = endpoint, batchSize = batchSize, loops = 20, base = base,
token = token, dimensions = dimensions, sample = "intelligent")
#visualise these datapoints in a 3D explorable space.
visualiseDatapoints(dataframe = dataframe, dimensions = dimensions, mode = "all")
source("sourcer.R")
#import data and build dataframe for observations and the two target variables.
dataframe = generateDataFrames(endpoint = endpoint, batchSize = batchSize, loops = 40, base = base,
token = token, dimensions = dimensions, sample = "intelligent")
#visualise these datapoints in a 3D explorable space.
visualiseDatapoints(dataframe = dataframe, dimensions = dimensions, mode = "all")
#import data and build dataframe for observations and the two target variables.
dataframe = generateDataFrames(endpoint = endpoint, batchSize = batchSize, loops = 100, base = base,
token = token, dimensions = dimensions, sample = "intelligent")
