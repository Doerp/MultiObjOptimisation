###Master###
source("sourcer.R")
base="optim.uni-muenster.de:5000/"
token="866de98d0d47426e92cc0e3394df5f07"

endpoint = "api-test2D"
dimensions = 2
batchSize = 50
MU = 30L; LAMBDA = 5L; MAX.ITER = 200L
algos = c("SVM", "XGB", "RF", "ANN", "KNN")

#all operations of the data take place here
#no external data may be generated - functional proramming; all data need to be returned to the master layer

#import data and build dataframe for observations and the two target variables. 
dataframe = generateDataFrames(endpoint = endpoint, batchSize = batchSize, loops = 100, base = base, 
                               token = token, dimensions = dimensions)

#visualise these datapoints in a 3D explorable space. 
visualiseDatapoints(dataframe = dataframe, dimensions = dimensions, mode = "all")

fn = prepareFunction()

#data is very much different in the two functions. Can we normalise them? I don't think so, right?

#try sequential models?



ggplot(data = dataframe , mapping = aes(x = func1, y = func2)) + geom_point()



# Calling the SVM model by Passing Dataframe as parameter
output_svm = Svm_model(df = dataframe)


# Calling the ANN model by Passing Dataframe as parameter
output_keras = kerasModel(df = dataframe)


rsq_1 = cor(x = dataframe$func1,output_svm$new_pred1)^2

rsq_2 = cor(x = dataframe$func2,output_svm$new_pred2)^2

rsq_1
rsq_2


# plotting func1 vs x1 (func1 is not dependent on x1)
ggplot(data = data.frame(scale(dataframe)), mapping = aes(x = x1, y = func1)) + geom_point()


# plotting func1 vs x2 (func1 is dependent on x2)
ggplot(data = data.frame(scale(dataframe)), mapping = aes(x = x2, y = func1)) + geom_point()


#respone of func2 vs x1 (func2 is dependent on x1)
ggplot(data = data.frame(scale(dataframe)), mapping = aes(x = x1, y = func2)) + geom_point()

# plotting func2 vs x2 (func2 is not dependent on x2)
ggplot(data = data.frame(scale(dataframe)), mapping = aes(x = x2, y = func2)) + geom_point()


head(output_keras)
head(output_svm)

# plotting approximations of func1 vs func2 from ANN
ggplot(data = output_keras , mapping = aes(x = pred_1 , y = pred_2)) + geom_point()


# plotting approximations of func1 vs func2 from SVM
ggplot(data = output_svm , mapping = aes(x = new_pred1 , y = new_pred2)) + geom_point()



source('SVM.R')

library(smoof)
library(ecr)

fn = makeAckleyFunction(2L,dimensions = 2)

fn




library(ggplot2)
library(plot3D)

obj.fn = makeRosenbrockFunction(dimensions = 2L)
print(obj.fn)
print(autoplot(obj.fn))
plot3D(obj.fn, length.out = 40L, contour = TRUE)


for(i in 1:4){
        print(i)
}


makeMultiObjectiveFunction()

getLowerBoxConstraints(output_svm[1])

fn = list(output_svm)

nsga2(fitness.fun = co,n.objectives = dataframe[1:50,c('x1','x2')],n.dim = 2,minimize = TRUE,lower = )
